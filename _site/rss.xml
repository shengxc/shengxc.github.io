<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
  <channel>
    <title>shengxc's blog</title>
    <description></description>
    <link>/rss.xml</link>
    <lastBuildDate>Sun, 08 Jun 2014 08:59:40 +0800</lastBuildDate>
    <pubDate>Sun, 08 Jun 2014 08:59:40 +0800</pubDate>
    <ttl>1800</ttl>

    
    <item>
      <title><![CDATA[局部加权回归和logistic回归]]></title>
      <description>&lt;h1 id=&quot;underfittingoverfitting&quot;&gt;欠拟合（underfitting）和过拟合（overfitting）&lt;/h1&gt;
&lt;p&gt;假设下图中的离散点为某地区房子大小（横轴）与房子价格（纵轴）之间的关系。
&lt;img src=&quot;/resource/2014-06-05-machinelearning/curvefit.png&quot; alt=&quot;拟合&quot; /&gt;
左图中的直线是对数据进行线性回归的结果，中间的图是把直线换成二次曲线所得的结果，而右边的是用5次曲线来拟合得到的完美通过每个坐标点的曲线（由于一共只有6个数据点，因此，5次曲线能够完美通过所有数据点）。左图拟合结果（欠拟合）中的直线无法很好的拟合给定的数据，数据中暗含的某些二次特征，而右图结果（过拟合）仅仅反映了数据本身的特性，而不是隐藏在数据之下的一般变化规律。中间图的拟合结果应该算是这三个中最好的一个。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;参数学习和非参数学习&lt;/h1&gt;

&lt;h2 id=&quot;parametric-learning-algorithm&quot;&gt;参数学习（parametric learning algorithm）&lt;/h2&gt;
&lt;p&gt;参数学习是一类有固定数目的参数可以用来进行数据拟合的算法，线性回归就是一种参数学习方法，其中的$\Theta$就是用来进行拟合的参数。&lt;/p&gt;

&lt;h2 id=&quot;non-parametric-learning-algorithm&quot;&gt;非参数学习（non-parametric learning algorithm）&lt;/h2&gt;
&lt;p&gt;参数的数目随着训练集合大小的增长而增长的一类机器学习算法。&lt;/p&gt;

&lt;h1 id=&quot;locally-weighted-regression&quot;&gt;局部加权回归（Locally weighted regression）&lt;/h1&gt;
&lt;p&gt;局部加权算法的主要思想是通过分段拟合给定的数据点的方法进行对训练数据的拟合。对训练集中每一个
拟合目标：
&amp;gt; 拟合出$\Theta$，使得$\sum_{i=1}^mw^{(i)}(y^{(i)}-\Theta^Tx^{(i)})^2$最小，其中$w^{(i)}=e^{(-\frac{(x^{(i)}-x)^2}{2})}$，在这种情况下，如果$x^{(i)}-x$很小时，那么$w^{(i)}$将会接近于$1$，否则$w^{(i)}$接近于$0$。这样，距离$x$点比较近的那些点对拟合结果会有较大的影响，而距离$x$较远的点，其影响被相对的忽略了。上述公式中的$w^{(i)}$只是一种常用的系数，可以由其他方法取代。一个一般化的方法是用$w^{(i)}=e^{(-\frac{(x^{(i)}-x)^2}{2\tau})}$来替换原来的$w$，这里的$\tau$是波长参数，其函数图像大致如下。&lt;img src=&quot;/resource/2014-06-05-machinelearning/exp.png&quot; alt=&quot;w函数图像&quot; /&gt; 通过调节$\tau$可以来控制权值$w$随距离变化的速率，如果$\tau$比较小，那么$w$的函数图像将会变得很窄，随着$\tau$的增大，函数图像将会变得越来越平坦。&lt;/p&gt;

&lt;h1 id=&quot;logistic&quot;&gt;logistic回归&lt;/h1&gt;

&lt;h2 id=&quot;section-1&quot;&gt;线性回归解决分类问题&lt;/h2&gt;
&lt;p&gt;如果有如下图绿色的点所示数据（x轴代表特征，y轴代表离散的两个类别，红色的直线是对这些数据点进行线性回归所拟合出来的直线）。&lt;img src=&quot;/resource/2014-06-05-machinelearning/linefit.png&quot; alt=&quot;直线拟合&quot; /&gt;，在这种情况下，对于一个新的数据点，只要其线性回归的函数预测结果以0.5为分解就可以很好的区分两类数据。但是，如果数据点的分布如下图所示&lt;img src=&quot;/resource/2014-06-05-machinelearning/wrongfit.png&quot; alt=&quot;错误的拟合&quot; /&gt;，那么0.5就无法作为临界值很好的区分这两类数据了。因此，通常情况下用线性回归来分类是个糟糕的选择。&lt;/p&gt;

&lt;h2 id=&quot;logistic-1&quot;&gt;logistic回归解决分类问题&lt;/h2&gt;
&lt;p&gt;假设分类问题的类别$y\in \{0,1\}$，logistic回归的拟合函数为$h_\Theta(X)=g(\Theta^TX)$,
其取值范围为&lt;script type=&quot;math/tex&quot;&gt;h_{\Theta(X)} \in [0,1]&lt;/script&gt;。
其中，&lt;script type=&quot;math/tex&quot;&gt;g(z)=\frac{1}{1+e^{-z}}&lt;/script&gt;(函数图像如下)&lt;img src=&quot;/resource/2014-06-05-machinelearning/logsticfunction.png&quot; alt=&quot;logstic回归函数图像&quot; /&gt;，因此，$h_\Theta(X)=g(\Theta^TX)=\frac{1}{1+e^{-\Theta^TX}}$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对logistic回归求解&lt;/strong&gt;
在logstic函数中，数据被分成两类的概率如下&lt;/p&gt;

&lt;p&gt;$\begin{align}&amp;amp;P(y=1|X;\Theta)=h_\Theta(X)\\&amp;amp;P(y=0|X;\Theta)=1-h_\Theta(X)\end{align}$&lt;/p&gt;

&lt;p&gt;上述函数可以写成一个公式$P(y|X;\Theta)=h_\Theta(X)^y(1-h_\Theta(X))^{1-y}$，参数$\Theta$的似然性$L(\Theta)$就是在该参数下数据出现的概率，计算公式如下
&lt;script type=&quot;math/tex&quot;&gt;L(\Theta)=\prod_{i=1}^mP(y^{(i)}|X^{(i)};\Theta)=\prod_{i=1}^{m}h_\Theta(X^{(i)})^{y^{(i)}}(1-h_\Theta(X^{(i)}))^{1-y^{(i)}}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;对上述公式取对数&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;l(\Theta)=log(L(\Theta))=\sum_{i=1}^m(y^{(i)}log(h_{\Theta}(X^{(i)}))+(1-y^{(i)})log(1-h_\Theta(X^{(i)})))&lt;/script&gt;

&lt;p&gt;根据最大似然估计，现在的目标是求得$\Theta$使得$l(\Theta)$最大。
这里可以使用类似于梯度下降的梯度上升算法来求$\Theta$，与梯度下降方法不同的是，这里$\Theta$的迭代公式是$\Theta:=\Theta+\alpha\nabla_\Theta{l(\Theta)}$(这个公式与梯度下降的不同之处是中间的+号)，为了导出梯度的上升方向，需要把$l(\Theta)$对每一个$\Theta$分量求偏导。&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\frac{\partial}{\partial{\Theta_j}}l(\Theta)=\sum_{i=1}^m(y^{(i)}-h_\Theta(X^{(i)}))X_j^{(i)}&lt;/script&gt;(这个公式我没有自己推导…)&lt;/p&gt;

&lt;p&gt;因此，梯度上升迭代过程如下:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Theta_j:=\Theta_j+\alpha\sum_{i=1}^m(y^{(i)}-h_\Theta(X^{(i)}))X_j^{(i)}&lt;/script&gt;

</description>
      <link>/2014-06/machinelearning.html</link>
      <guid>/2014-06/machinelearning</guid>
      <pubDate>Thu, 05 Jun 2014 00:00:00 +0800</pubDate>
    </item>
    
    <item>
      <title><![CDATA[数学中的数系]]></title>
      <description>&lt;ul&gt;
  &lt;li&gt;$\sqrt{2}$是无理数的证明&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果$\sqrt{2}$是有理数，则$\sqrt{2}=p/q$（取$p,q$互质，则等号右边的分数不可化简），由此可以推出$p^2=2q^2$。由$p^2=2q^2$可知$p^2$是偶数，故$p$是偶数，假设$p=2r$,可得$(2r)^2=4r^2=2q^2$可以化简，得出矛盾，因此$\sqrt{2}$是无理数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;所有无限循环小数都是有理数&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;无限循环小数$p=0.a_1a_2…a_mb_1b_2…b_nb_1b_2…b_n…$。令$B=0.b_1b_2…b_n$,则$p=0.a_1a_2…a_m+10^{-m}B(1+10^{-n}+10^{-2n}+10^{-3n}+…)=0.a_1a_2…a_m+B\frac{10^{-m}}{1-10^{-n}}$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section&quot;&gt;无限的数学分析&lt;/h1&gt;

&lt;h2 id=&quot;section-1&quot;&gt;定义&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;等势&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果两个集合A,B可以按如下方式彼此配对，使得A的每一个元素在B中有且仅有一个对应的元素，而B中每个元素在A中有且仅有一个对应元素，那么这个对应称为一一对应，而且，称A,B&lt;strong&gt;等势&lt;/strong&gt;。对有限集来说，等势意味着集合中所含元素个数相等&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可数性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;和自然数集的某个子集等势的集合称为&lt;strong&gt;可数集合&lt;/strong&gt;，其他集合称为&lt;strong&gt;不可数集&lt;/strong&gt;，可数集的元素，正如其名，是“可以计数”的：尽管计数可能永远无法终止，集合中每一个特定的元素都将对应一个自然数。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;基数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果两个集合$A,B$是等势的，我们就认为他们有&lt;strong&gt;相同的基数&lt;/strong&gt;，如果集$A$和集$B$的某个子集等势，而集$B$不等势于集$A$或它的任意子集等集$B$有一个比集$A$更大的&lt;strong&gt;基数&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;定理&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;正有理数集是可数的&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;每一个正有理数都可以表示为$\frac{a}{b}(a,b是整数)$的形式，将这些数排列成一个矩阵，使得$\frac{a}{b}$在第$a$列第$b$行(如左图所示)，并将其按照右图箭头所示方向排列：
&lt;img src=&quot;/resource/count.jpg&quot; alt=&quot;正有理数集的排列&quot; /&gt;
最后，在得到的序列中，将所有$a$和$b$有公因子的$\frac{a}{b}$消去，最终得到一个正有理数序列，使得每一个正有理数都恰好出现一次，因此，正有理数集是可数的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;全体实数集是不可数的&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;假设实数集可数，那么全体实数可构成一个如下无限十进位小数的排列
第一个数 $N_1.a_1a_2a_3…,$
第二个数 $N_2.b_1b_2b_3…,$
第三个数 $N_1.c_1c_2c_3…,$
…            …
现在来构造一个不属于上述排列中的实数，这样便可引出矛盾，假设不成立。选取一个数码$z=0.abcde….$使得${a}\neq{a_1},{b}\neq{b_2},{c}\neq{c_3}…$，同时，$z$的小数部分所有数都不等于0和9(避免$0.999…=1$这种情况)，这样构造出来的$z$不属于上述排列。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;对任意给定集合$A$，可以构造一个具有更大基数的集合$B$&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;B的构造方法：$B$是由$A$的所有子集组成的集合
证明：假设$A,B$等势，即有一个从集合$A$的元素$a$到其某一子集$S_a$的对应规则${a}\leftrightarrow{S_a}$,构造$B$的一个元素$T$，它不能和任意$a$相对应，引出矛盾以证明$B$的基数大于$A$。
定义$T$为$A$的一个子集，它包含所有使$S_a$不包含$a$的那些元素$a$。这个集合跟每一个$S_a$都相差一个元素$a$，因为，如果$S_a$包含$a$，则$T$不包含$a$，反之，$S_a$不包含$a$,则$T$包含$a$，因此$T$不包含在对应${a}\leftrightarrow{S_a}$中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-3&quot;&gt;有关无限的悖论&lt;/h2&gt;
&lt;p&gt;不包含自身为元素的集合为普通集（如所有整数组成的集合）；而包含自身为元素的集合称为非普通集（如凡是可以用不超过30个字来定义的集合的集合）。对于所有普通集组成的集合C，它本身必须为普通集或非普通集二者之一。如果C是普通集，那么它应该包含自身，这是一个矛盾，因此它只能是非普通集；而非普通集包含自身作为元素，自身是非普通集，与集C的定义矛盾。&lt;/p&gt;

&lt;h1 id=&quot;section-4&quot;&gt;复数&lt;/h1&gt;
&lt;p&gt;复数$z=x+yi$可以在直角坐标系中用点$z(x,y)$来表示，其模为该点到原点的距离，为$\rho=\sqrt{x^2+y^2}$，辐角为$x$轴正向和$Oz$直线之间的夹角，记为$\phi$。因此，$z$也可以表示为$z=\rho(cos\phi+isin\phi)$&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;两个复数相乘就是把它们的模相乘，辐角相加&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;证明：$z=\rho(cos\phi+isin\phi)$，$z’=\rho’(cos\phi’+isin\phi’)$。计算$zz’$，利用三角函数关系可证。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section-5&quot;&gt;代数数和超越数&lt;/h1&gt;

&lt;p&gt;任意一个数$x$，不论是实数还是复数，如果满足某个形如$a_nx^n+a_{n-1}x^{n-1}+…+a_1x+a_0=0(n\ge1,a_n\neq0)(1)$的代数方程，其中$a_i$是整数，那么这个数就是一个&lt;strong&gt;代数数&lt;/strong&gt;。当$n=1$时，上述方程的根就是有理数。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;全体代数数是可数的，而实数是不可数的，因此，必定存在不是代数数的实数，这样的数称为&lt;strong&gt;超越数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;代数数的可数枚举方式：
对于形如(1)的方程，定义正整数$h=|a_n|+|a_{n-1}|+…+|a_0|+n$为它的高，对于每一个固定的高$h$，只有有限个形如(1)的方程，而每一个这样的方程至多有$n$个不同的根，因此，高为$h$的方程只能有有限个代数数。这样，就可以从高为1开始递增排列方程(1)的根，形成一个代数数的排列。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
      <link>/2014-05/read_notes.html</link>
      <guid>/2014-05/read_notes</guid>
      <pubDate>Wed, 21 May 2014 00:00:00 +0800</pubDate>
    </item>
    
    <item>
      <title><![CDATA[监督学习:线性回归]]></title>
      <description>&lt;h1 id=&quot;linear-regression&quot;&gt;线性回归（Linear Regression）&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;符号说明&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;$X^{(i)}$:features&lt;/li&gt;
  &lt;li&gt;$y^{(i)}$:target&lt;/li&gt;
  &lt;li&gt;$(X^{(i)},y^{(i)})$:$i^{th}$training example&lt;/li&gt;
  &lt;li&gt;$m$:the number of training examples&lt;/li&gt;
  &lt;li&gt;$n$:the size of feature&lt;/li&gt;
  &lt;li&gt;$\Theta$：parameter vector&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;回归模型&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;线性回归模型为&lt;script type=&quot;math/tex&quot;&gt;h_{\Theta}(x)=\Theta_0+\sum_{i=1}^{n}\Theta_ix_i&lt;/script&gt;
令$x_0=1$,则特征向量$X=[x_0,x_1,…,x_n]^T$,模型可表示为
&lt;script type=&quot;math/tex&quot;&gt;h_{\Theta}(x)=\Theta_0+\sum_{i=1}^{n}\Theta_ix_i=\Theta^TX&lt;/script&gt;
机器学习算法的目的是学出上述$\Theta$向量，这样，便可对任意输入$X$向量得到上述$h_{\Theta}(x)$作为预测输出。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-2&quot;&gt;目标函数&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;cost function为&lt;script type=&quot;math/tex&quot;&gt;J(\Theta)=\frac{1}{2}\sum_{i=1}^m(h_{\Theta}(X^{(i)})-y^{(i)})^2&lt;/script&gt;由此，机器学习算法的目标可描述如下 &lt;script type=&quot;math/tex&quot;&gt;\min_{\Theta}J(\Theta)&lt;/script&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section-3&quot;&gt;解法&lt;/h1&gt;

&lt;h2 id=&quot;section-4&quot;&gt;梯度下降&lt;/h2&gt;

&lt;h3 id=&quot;batch-gradient-descent&quot;&gt;批量梯度下降(Batch gradient descent)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;基本思想&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;从某一特定$\Theta$开始，不断改变$\Theta$的取值来降低$J(\Theta)$直到收敛。此算法会收敛到local minimum，不同的初始$\Theta$也有可能收敛到不通的local minimum。（如果是线性回归，$J(\theta)$只有一个最小值）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;算法流程&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;任意给定一个初始$\Theta$值&lt;/li&gt;
    &lt;li&gt;对于$\Theta$中所有分量，更新$\Theta_i := \Theta_i-\alpha\frac{\partial}{\partial\Theta_i}J(\Theta)$(此步即梯度下降，$\alpha$是步长)&lt;/li&gt;
    &lt;li&gt;当cost function的变化小于某个给定阈值的时候算法停止&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;公式推导&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\frac{\partial}{\partial\Theta_i}J(\Theta)=\frac{\partial}{\partial\Theta_i}\frac{1}{2}\sum_{i=1}^m(h_{\Theta}(X^{(i)})-y^{(i)})^2=\sum_{j=1}^m(h_{\Theta}(X^{(j)})-y^{(j)})X^{(j)}_i&lt;/script&gt;
将此公式带入算法流程中的第二步既得完整的算法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;stochastic-gradient-descent&quot;&gt;随机梯度下降(Stochastic gradient descent)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;在批量梯度下降算法中，每次迭代都要遍历所有训练样本，当训练样本很多(m很大)时，算法的运行效率会变得很低。随机梯度下降算法会有比批量梯度下降算法快的多的下降速度。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;算法流程&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;任意给定一个初始$\Theta$值&lt;/li&gt;
    &lt;li&gt;更新$\Theta_i$&lt;/li&gt;
    &lt;li&gt;当cost function的变化小于某个给定阈值的时候算法停止&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;随机梯度下降算法跟批量梯度下降算法之间的不同之处在于第2步更新$\Theta$的方法。再随机梯度下降算法中，更新$\Theta$的方法是遍历每一个训练样本$(X^{(j)},y^{(j)})$按照以下公式更新$\Theta$所有的分量。
&lt;script type=&quot;math/tex&quot;&gt;\Theta_i:=\Theta_i-\alpha(h_{\Theta}(X^{(j)})-y^{(j)})X^{(j)}_i\ (for\ i = 0\ to\ n)&lt;/script&gt;
随机梯度下降是通过每个样本来迭代更新一次，如果样本量很大，那么可能只用其中一部分样本，就已经将$\Theta$迭代到最优解了，对比上面的批量梯度下降，迭代一次需要用到所有训练样本，随机梯度下降算法快的多。但是，该算法并不是每次迭代都向着整体最优化方向下降。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-5&quot;&gt;矩阵方法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;符号定义&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$\bigtriangledown_{\Theta}J=\begin{bmatrix}\frac{\partial{J}}{\partial\Theta_0} \\ … \\ \frac{\partial{J}}{\partial\Theta_n}\end{bmatrix} \in R^{n+1}$
  由上述符号，随机梯度下降算法迭代公式可表示为$\Theta=\Theta-\alpha\bigtriangledown_{\Theta}J\ \ (\Theta\in R^{n+1})$&lt;/li&gt;
  &lt;li&gt;$f:R^{m\times n}\to R$&lt;/li&gt;
  &lt;li&gt;$A \in R^{m\times n}$&lt;/li&gt;
  &lt;li&gt;$\bigtriangledown_{A}f(A)=\begin{bmatrix}\frac{\partial{f}}{\partial A_{11}}&amp;amp;…&amp;amp; \frac{\partial{f}}{\partial A_{1n}}\\ …&amp;amp;…&amp;amp;… \\ \frac{\partial{f}}{\partial A_{m1}}&amp;amp;…&amp;amp;\frac{\partial{f}}{\partial A_{mn}}\end{bmatrix}$&lt;/li&gt;
  &lt;li&gt;$X \in R^{n\times n}$&lt;/li&gt;
  &lt;li&gt;$trX=\sum_{i=1}^{n}X_{ii}$ ($trX$表示矩阵$X$的迹)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;不加证明的一些定理&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$trAB=trBA$&lt;/li&gt;
  &lt;li&gt;$trABC=trCAB=trBCA$&lt;/li&gt;
  &lt;li&gt;$\bigtriangledown_{A}trAB=B^T$&lt;/li&gt;
  &lt;li&gt;$trA=trA^T$&lt;/li&gt;
  &lt;li&gt;$tra=a\ (a\in R)$&lt;/li&gt;
  &lt;li&gt;$\bigtriangledown_{A}trABA^TC=CAB+C^TAB^T$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;梯度下降的推导&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;定义矩阵&lt;script type=&quot;math/tex&quot;&gt;X=\begin{bmatrix}(X^{(1)})^T\\\\...\\\\(X^{(m)})^T\end{bmatrix}&lt;/script&gt;
根据训练样本构造向量
&lt;script type=&quot;math/tex&quot;&gt;X\Theta=\begin{bmatrix}(X^{(1)})^T\\\\...\\\\(X^{(m)})^T\end{bmatrix}\Theta=\begin{bmatrix}(X^{(1)})^T\Theta\\\\...\\\\(X^{(m)})^T\Theta\end{bmatrix}=\begin{bmatrix}h_\Theta(X^{(1)})\\\\...\\\\h_\Theta(X^{(m)})\end{bmatrix}&lt;/script&gt;
&lt;script type=&quot;math/tex&quot;&gt;Y=\begin{bmatrix}y^{(1)}\\\\...\\\\y^{(m)}\end{bmatrix}&lt;/script&gt;
将上述两个向量相减，得&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;X\Theta-Y=\begin{bmatrix}h_\Theta(X^{(1)})-y^{(1)}\\\\...\\\\h_\Theta(X^{(m)})-y^{(m)}\end{bmatrix}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(X\Theta-Y)^T(X\Theta-Y)=\sum_{i=1}^m(h_\Theta(X^{(i)})-y^{(i)})^2=2J(\Theta)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Rightarrow J(\Theta)=\frac{1}{2}(X\Theta-Y)^T(X\Theta-Y)&lt;/script&gt;

&lt;p&gt;要使$J(\Theta)$取得最小值，则需要满足$J(\Theta)$对$\Theta$的导数等于0向量，即
&lt;script type=&quot;math/tex&quot;&gt;\bigtriangledown_{\Theta}J(\Theta)=\vec{0}&lt;/script&gt;
由$J(\Theta)$的计算公式可知&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;J(\Theta)=\frac{1}{2}(X\Theta-Y)^T(X\Theta-Y)=\frac{1}{2}(\Theta^TX^T-Y^T)(X\Theta-Y)=\frac{1}{2}(\Theta^TX^TX\Theta-\Theta^TX^TY-Y^TX\Theta+Y^TY)&lt;/script&gt;

&lt;p&gt;$J(\Theta)$是一个实数，所以&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\bigtriangledown_{\Theta}J(\Theta)=\bigtriangledown_{\Theta}trJ(\Theta)=\frac{1}{2}(\bigtriangledown_{\Theta}tr\Theta^TX^TX\Theta-\bigtriangledown_{\Theta}tr\Theta^TX^TY-\bigtriangledown_{\Theta}trY^TX\Theta+\bigtriangledown_{\Theta}trY^TY)&lt;/script&gt;

&lt;p&gt;逐项分析：
第一项&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\bigtriangledown_{\Theta}tr\Theta^TX^TX\Theta=\bigtriangledown_{\Theta}tr\Theta\Theta^TX^TX=\bigtriangledown_{\Theta}tr\Theta I\Theta^TX^TX=X^TX\Theta+X^TX\Theta&lt;/script&gt;

&lt;p&gt;上述推导最后一步把$\Theta$看作$A$，$I$看作$B$,$X^TX$看作$C$,应用上一小结中最后一条定理，$I$为单位矩阵
第二项
由于\Theta^TX^TY是一个实数，所以&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\bigtriangledown_{\Theta}tr\Theta^TX^TY=\bigtriangledown_{\Theta}trY^TX\Theta=(Y^TX)T=X^TY&lt;/script&gt;

&lt;p&gt;上述推导中倒数第二步是把$Y^TX$看作$B$，$\Theta$看作$A$，利用上一小节中的定理三得到的。
第三项与第二项相同，第四项与$\Theta$无关，因此求导后为0,可以忽略。
最终可得&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\bigtriangledown_{\Theta}J(\Theta)=\frac{1}{2}(X^TX\Theta+X^TX\Theta-X^TY-X^TY)=0&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Rightarrow X^TX\Theta=X^TY&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Rightarrow \Theta=(X^TX)^{-1}X^TY&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Tips&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果$X^TX$不可逆，可以用伪逆的方式计算，但一般情况下这种情况是因为特征选取的时候有依赖造成的。&lt;/p&gt;

</description>
      <link>/2014-05/machinelearning.html</link>
      <guid>/2014-05/machinelearning</guid>
      <pubDate>Wed, 21 May 2014 00:00:00 +0800</pubDate>
    </item>
    
    <item>
      <title><![CDATA[python的闭包和修饰器]]></title>
      <description>&lt;h1 id=&quot;section&quot;&gt;闭包&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&quot;&gt;闭包&lt;/a&gt; （&lt;a href=&quot;en_wiki&quot;&gt;Closure&lt;/a&gt;）是引用了自由变量的函数体，该被引用的自由变量将与函数一同存在，即使离开了创造它的环境也不例外。以下代码是一个简单的闭包例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#-*-coding:utf-8-*-
def start(x):
  def increment(y):
    return x + y
  return increment
f = start(0) #初始化基数为0的increment函数
print f(1)
print f.__closure__  #一个cell的tuple，每个cell存储闭包所引用的变量
print [cell.cell_contents for cell in f.__closure__]

#output
1
(&amp;lt;cell at 0x7f068d751398: int object at 0x1ff5170&amp;gt;,)
[0] # 装饰器（Decorators） ## 函数装饰器
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;不带参数的装饰器&lt;/h3&gt;
&lt;p&gt;python中的函数装饰器是指某些函数以函数作为输入参数，返回被装饰过的函数的形式。下面是一个为函数运行计时的装饰器，该装饰器输出它装饰的函数的开始时间，终止时间以及运行时间。是一个不带输入参数的函数装饰器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#-*-coding:utf-8-*-
import time
def timing(func):
  def inner_func(*args,**kwargs):
    start = time.time()
    print &quot;start at:&quot;,start
    func(*args,**kwargs)
    end =time.time()
    print &quot;end at:&quot;,end
    print &quot;used:&quot;, end - start
  return inner_func
@timing #装饰器语法糖，该语句等价于在定义完add函数之后再加上add=timing(add)
def add(x,y):
  time.sleep(1)
  return x + y
add(1,2)

#output
start at: 1399482192.25
end at: 1399482193.25
used: 1.00104689598
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;带参数的装饰器&lt;/h3&gt;
&lt;p&gt;上述计时装饰器输出的函数开始时间和终止时间都难以读懂，因此，可以在装饰器中传输参数，以格式化要输出的时间，代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#-*-coding:utf-8-*-
import time
def timing(time_format):
  def decorator(func):
    def inner_func(*args,**kwargs):
      start = time.time()
      print &quot;start at:&quot;,time.strftime(time_format)
      func(*args,**kwargs)
      end =time.time()
      print &quot;end at:&quot;,time.strftime(time_format)
      print &quot;used:&quot;, end - start
    return inner_func
  return decorator
@timing(&quot;%b %d %Y - %H:%M:%S&quot;) #timing装饰器传入time_format格式化字符串后依旧是一个以函数作为参数，返回函数的函数，即decorator函数
def add(x,y):
  time.sleep(1)
  return x + y
add(1,2)

#output:
start at: May 08 2014 - 01:30:21
end at: May 08 2014 - 01:30:22
used: 1.00109791756 ## 类装饰器 类装饰器类似于函数装饰器，不过这次，被装饰的不是函数，而是类，因此，类装饰器的形式是输入类，输出类的函数，下面是一个对类中所有函数计时的装饰器函数

#-*-coding:utf-8-*-
import time
from functools import wraps
def timing(time_format,class_name):
  def decorator(func):
    @wraps(func)  #防止func函数的__name__,__doc__,__module__被修改,如果没有这个装饰器，那么func函数上述属性将被修改为inner_func的相应属性，比如func.__name__将会变成&quot;inner_func&quot;，这样，在下面的代码中就无法正确地输出测试时间的函数名了
    def inner_func(*args,**kwargs):
      start = time.time()
      print class_name + &quot;.&quot; + func.__name__
      print &quot;\tstart at: %s&quot;,time.strftime(time_format)
      func(*args,**kwargs)
      end =time.time()
      print &quot;\tend at:&quot;,time.strftime(time_format)
      print &quot;\tused:&quot;, end - start
    return inner_func
  return decorator
def class_timing(time_format):
  def decorator(cls):
    for attr in dir(cls):
      if attr.startswith(&quot;__&quot;): #对于类中自带的函数，不做任何修改
        continue
      candidate_func = getattr(cls,attr)
      if hasattr(candidate_func,'__call__'):
        setattr(cls,attr,timing(time_format,cls.__name__)(candidate_func)) #将利用timing函数装饰器装饰cls类中可以执行的函数，并将其重新设置回cls类中
    return cls
  return decorator
@class_timing(&quot;%b %d %Y - %H:%M:%S&quot;)
class calculate:
  def add(self,x,y):
    time.sleep(1)
    return x + y
  def minus(self,x,y):
    time.sleep(1)
    return x - y
c = calculate();
c.add(1,2)
c.minus(1,2)

#output:
calculate.add
	start at: %s May 08 2014 - 02:06:02
	end at: May 08 2014 - 02:06:03
	used: 1.00110793114
calculate.minus
	start at: %s May 08 2014 - 02:06:03
	end at: May 08 2014 - 02:06:04
	used: 1.00110197067
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述类装饰器class_timing的实现是对类中每一个非自带的可执行对象利用前面定义的函数装饰器依次修饰，并返回被修饰过的类。&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&quot;http://blog.jobbole.com/66895/&quot;&gt;Python高级特性（2）：Closures、Decorators和functools&lt;/a&gt;&lt;/p&gt;

</description>
      <link>/2014-05/python0.html</link>
      <guid>/2014-05/python0</guid>
      <pubDate>Wed, 07 May 2014 00:00:00 +0800</pubDate>
    </item>
    
    <item>
      <title><![CDATA[自然数和数论]]></title>
      <description>&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;关于素数有无穷多个的证明
 &amp;gt; 假设素数有$n$个，则所有素数可以用$p_1,p_2,…,p_n$表示，构造$A=p_1p_2p_3…p_n+1$,$A$比这些$p$中的任何一个数都大，因而，必须是合数。同时用$p_1,p_2,…,p_n$去除A所得的余数都是$1$，因此，这些$p$都不是$A$的因子，这与$A$是合数这个结论矛盾，因此，假设不成立，命题得证。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Eratosthems筛法求自然数$N$之前的素数表
 &amp;gt; 按大小顺序列出从2到$N$的自然数，然后从2开始，删除2的倍数，然后再删除剩下的第一个数的倍数…一直进行到$\sqrt{N}$，所有剩下的数就是$N$之前的素数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;能被整数$11$整除的整数的性质
 &amp;gt; 由于$10=-1+11$,所以$10\equiv-1(mod\  11)$，由同余的乘积性质，可以得到以下一系列同余式：
 &amp;gt;&amp;lt;table&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;$10^2\equiv(-1)(-1) = 1 (mod\ 11)$&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;$10^3\equiv-1(mod\ 11)$&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;$…$&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;/table&amp;gt;
 &amp;gt; 任何一个整数$z$可以表示为$z=a_0+a_1\star10+a_2\star10^2+…+a_n\star10^n$，构造$t=a_0-a_1+a_2-a_3+…$，因为对于$z-t=a_1\star11+a_2\star(10^2-1)+a_3\star(10^3+1)+…$中，所有的加数中的第二项和$0$都是模$11$同余的，因此，$z$和$t$模$11$同余，由此可知：&lt;strong&gt;一个数能被11整除当且仅当它的数码交替变号之和能被11整除&lt;/strong&gt;
 &amp;gt; 类似的，可以证明&lt;strong&gt;一个能被$3$或$9$整除的数，必须而且只须它的数码之和也同样相应地被$3$或$9$整除&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;费马定理:&lt;strong&gt;如果$p$是任意一个不能整除整数$a$的素数，则$a^{p-1}\equiv1(mod\ p)$&lt;/strong&gt;
 &amp;gt; 证：考虑$a$的倍数：$m_1=a,m_2=2a,…,m&lt;em&gt;{p-1}=(p-1)a$,可以证明*这些m中的任意两个都不能模p同余且都不能整除p*，因此，这些$m$总有一个排列$m_1’,m_2’,…,m&lt;/em&gt;{p-1}’$使得它们相应地同余于$1,2,3,..,p-1$，即$m_1m_2…m_{p-1}=1\star2\star3…(p-1)a^{p-1}\equiv1\star2\star3…(p-1)(mod\ p)$。记$K=1\star2\star3\star…\star(p-1)$，则上式等价于$K(a^{p-1})\equiv K(mod\ p)$因此$K(a^{p-1}-1)\equiv0(mod\ p)$,而$K$的所有因子都无法整除$p$，所以$a^{p-1}-1\equiv0(mod\ p)$，这就是费马定理。&lt;br /&gt;
 &amp;gt; 上述斜体字部分的证明如下：若由于$a$不能整除$p$，所以，所有的$m$都不能整除$p$。同时如果这些$m$中有两个模$p$同余，那么必然存在某一对整数$r$,$s$，满足$1\leq r &amp;lt; s\leq(p-1)$,使得$p$成为$(s-r)a$的一个因子，然而$s-r &amp;lt; p$，不能整除$p$，而$a$也不能整除$p$,因此$(s-r)a$不能整除$p$，得出矛盾，命题得证。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;欧几里德辗转相除法求两个整数的最大公因数
 &amp;gt; 假设整数$a,b(a&amp;gt;b)$的最大公因数用$(a,b)$表示，$a/b$的商为$q$,余数为$r$。&lt;br /&gt;
 &amp;gt; 对于任意同时整除$a,b$的整数$u$，有$a=su,b=tu$，它也整除$r$,因为$r=a-bq=su-tuq=(s-qt)u$同理可知，任意整除$b,r$的整数同时也整除$a$，因此$(a,b)=(b,r)$&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
      <link>/2014-05/read_notes.html</link>
      <guid>/2014-05/read_notes</guid>
      <pubDate>Mon, 05 May 2014 00:00:00 +0800</pubDate>
    </item>
    
    <item>
      <title><![CDATA[零星的面试记忆]]></title>
      <description>&lt;p&gt;记录一下最近碰到的一些面试题目&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果有一个很大的文件(比如10G)存放在1台电脑上，现要将其拷贝至10台不同的电脑，应该怎么做？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;最简单的当然是每台电脑依次拷贝，但这肯定不算是一个好方法，然后问了下面试官这些机器之间是否存在网络连接，得到肯定回答，并且每台电脑都相互连接，然后我的回答是将大文件切成很多小块数据，并将这些数据包向与其相连的机器发送，这样，每台机器都能从不同的邻居处获得不同的数据包。然后被追问这样做的时间复杂度是多少，对于这个问题，虽然被提示了很多很多，但我还是没有分析出来，完全不知道如何入手。。。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个有序数组，如果其中某一元素出现的次数超过数组大小的一半，如何快速将其找出来？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;当时看到这个问题第一反应就是我做过，然后将经典的两个不同的数组两两抵消，最终剩下的数组就是结果这个方法告诉了面试官，面试官提示效率不高，让我看清题目条件，仔细一看才发现是有序数组，当时就知道悲剧了，然后只能硬着头皮回答说数组中间那个数就是，追问，如果没有一个数出现次数超过一半怎么办？我给出的解决方案是找到中间那个数后向左右分别二分搜索，查找两个端点，然后相减查看距离是否超过一半。接着又问一定要两边都查找吗？当时一直没想出来，等到面完才想到找了一边之后相另一边走数组长度的一半，看看是否相同的数便可搞定。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于正方形：有4个点（0维元素）；4条边（1维元素）；1个面（2维元素）。&lt;br /&gt;
对于立方体：有8个点（0维元素）；12条边（1维元素）；8个面（2维元素）；1个体（3维元素）&lt;br /&gt;
问：一个4维立方体有几个点，边，面，体和4维空间元素？追问，对于n维空间中立方体（这么叫可能不合适，不过管他呢）的k维元素，其出现次数又是怎么样的？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;当假设&lt;code&gt;n&lt;/code&gt;维空间中的立方体中&lt;code&gt;k&lt;/code&gt;维元素共有&lt;code&gt;f(n,k)&lt;/code&gt;个（&lt;code&gt;n&amp;gt;0&lt;/code&gt;且&lt;code&gt;k&amp;gt;=0&lt;/code&gt;）:&lt;br /&gt;
对于0维元素（点）来说，很简单，每升一个维度都乘以2，因此&lt;code&gt;f(n,0)=2^n&lt;/code&gt;。&lt;br /&gt;
对于&lt;code&gt;f(1,k)&lt;/code&gt;来说：显然&lt;code&gt;f(1,0)=2&lt;/code&gt;；&lt;code&gt;f(1,1)=1&lt;/code&gt;；&lt;code&gt;f(1,k)=0 if k&amp;gt;1&lt;/code&gt;。&lt;br /&gt;
&lt;code&gt;n&lt;/code&gt;维空间立方体中的&lt;code&gt;k&lt;/code&gt;维元素可以看作是由&lt;code&gt;n-1&lt;/code&gt;维空间立方体中固有的&lt;code&gt;k-1&lt;/code&gt;维元素移动产生，因此，&lt;code&gt;f(n,k)=f(n-1,k-1)+2f(n-1,k)&lt;/code&gt;。&lt;br /&gt;
下表是上述分析的示意图，表中数字是初始化状态，空格中的数字可由已有元素通过上述函数得到&lt;/p&gt;

      &lt;table width=&quot;100%&quot; border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;font color=&quot;red&quot;&gt;n\k&lt;/font&gt;&lt;/td&gt;&lt;td&gt;&lt;font color=&quot;red&quot;&gt;0&lt;/font&gt;&lt;/td&gt;&lt;td&gt;&lt;font color=&quot;red&quot;&gt;1&lt;/font&gt;&lt;/td&gt;&lt;td&gt;&lt;font color=&quot;red&quot;&gt;2&lt;/font&gt;&lt;/td&gt;&lt;td&gt;&lt;font color=&quot;red&quot;&gt;3&lt;/font&gt;&lt;/td&gt;&lt;td&gt;&lt;font color=&quot;red&quot;&gt;...&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;font color=&quot;red&quot;&gt;1&lt;/font&gt;&lt;/td&gt;&lt;td&gt;2^1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;...&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;font color=&quot;red&quot;&gt;2&lt;/font&gt;&lt;/td&gt;&lt;td&gt;2^2&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;font color=&quot;red&quot;&gt;...&lt;/font&gt;&lt;/td&gt;&lt;td&gt;...&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;font color=&quot;red&quot;&gt;n&lt;/font&gt;&lt;/td&gt;&lt;td&gt;2^n&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
      <link>/2014-05/interview_record.html</link>
      <guid>/2014-05/interview_record</guid>
      <pubDate>Fri, 02 May 2014 00:00:00 +0800</pubDate>
    </item>
    
    <item>
      <title><![CDATA[第一篇博客]]></title>
      <description>&lt;p&gt;作为一个从小就不会写作文的人，第一篇博客实在是太难写了，不过既然折腾了这么久，就不能放弃最初那个写博客冲动，以后尽量多写博客，记录学习经历。&lt;/p&gt;

&lt;p&gt;感谢&lt;a href=&quot;http://havee.me&quot;&gt;Havee&lt;/a&gt;的jekyll-bootstrap模板&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;作为一个码农&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
int main(int argc,char** argv){
  printf(&quot;Hello world!\n&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

</description>
      <link>/2014-05/hello.html</link>
      <guid>/2014-05/hello</guid>
      <pubDate>Thu, 01 May 2014 00:00:00 +0800</pubDate>
    </item>
    
  </channel>
</rss>
