<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title>shengxc's blog</title>
  <link href="//atom.xml" rel="self"/>
  <link href=""/>
  <updated>2014-06-08T08:59:40+08:00</updated>
  <id></id>
  <author>
    <name></name>
  </author>

  
  <entry>
    <title>局部加权回归和logistic回归</title>
    <link href="/2014-06/machinelearning.html"/>
    <updated>2014-06-05T00:00:00+08:00</updated>
    <id>/2014-06/machinelearning</id>
    <content type="html">欠拟合（underfitting）和过拟合（overfitting）
假设下图中的离散点为某地区房子大小（横轴）与房子价格（纵轴）之间的关系。

左图中的直线是对数据进行线性回归的结果，中间的图是把直线换成二次曲线所得的结果，而右边的是用5次曲线来拟合得到的完美通过每个坐标点的曲线（由于一共只有6个数据点，因此，5次曲线能够完美通过所有数据点）。左图拟合结果（欠拟合）中的直线无法很好的拟合给定的数据，数据中暗含的某些二次特征，而右图结果（过拟合）仅仅反映了数据本身的特性，而不是隐藏在数据之下的一般变化规律。中间图的拟合结果应该算是这三个中最好的一个。

参数学习和非参数学习

参数学习（...</content>
  </entry>
  
  <entry>
    <title>数学中的数系</title>
    <link href="/2014-05/read_notes.html"/>
    <updated>2014-05-21T00:00:00+08:00</updated>
    <id>/2014-05/read_notes</id>
    <content type="html">
  $\sqrt{2}$是无理数的证明



  如果$\sqrt{2}$是有理数，则$\sqrt{2}=p/q$（取$p,q$互质，则等号右边的分数不可化简），由此可以推出$p^2=2q^2$。由$p^2=2q^2$可知$p^2$是偶数，故$p$是偶数，假设$p=2r$,可得$(2r)^2=4r^2=2q^2$可以化简，得出矛盾，因此$\sqrt{2}$是无理数



  所有无限循环小数都是有理数



  无限循环小数$p=0.a_1a_2…a_mb_1b_2…b_nb_1b_2…b_n…$。令$B=0.b_1b_2…b_n$,则$p=0.a_1a_2…a_m+10^{-m}B(...</content>
  </entry>
  
  <entry>
    <title>监督学习:线性回归</title>
    <link href="/2014-05/machinelearning.html"/>
    <updated>2014-05-21T00:00:00+08:00</updated>
    <id>/2014-05/machinelearning</id>
    <content type="html">线性回归（Linear Regression）

符号说明

  $X^{(i)}$:features
  $y^{(i)}$:target
  $(X^{(i)},y^{(i)})$:$i^{th}$training example
  $m$:the number of training examples
  $n$:the size of feature
  $\Theta$：parameter vector


回归模型

  线性回归模型为
令$x_0=1$,则特征向量$X=[x_0,x_1,…,x_n]^T$,模型可表示为

机器学习算法的目的是学出上述$\Theta$向量，...</content>
  </entry>
  
  <entry>
    <title>python的闭包和修饰器</title>
    <link href="/2014-05/python0.html"/>
    <updated>2014-05-07T00:00:00+08:00</updated>
    <id>/2014-05/python0</id>
    <content type="html">闭包
闭包 （Closure）是引用了自由变量的函数体，该被引用的自由变量将与函数一同存在，即使离开了创造它的环境也不例外。以下代码是一个简单的闭包例子：

#-*-coding:utf-8-*-
def start(x):
  def increment(y):
    return x + y
  return increment
f = start(0) #初始化基数为0的increment函数
print f(1)
print f.__closure__  #一个cell的tuple，每个cell存储闭包所引用的变量
print [cell.cell_contents for c...</content>
  </entry>
  
  <entry>
    <title>自然数和数论</title>
    <link href="/2014-05/read_notes.html"/>
    <updated>2014-05-05T00:00:00+08:00</updated>
    <id>/2014-05/read_notes</id>
    <content type="html">
  
    关于素数有无穷多个的证明
 &amp;gt; 假设素数有$n$个，则所有素数可以用$p_1,p_2,…,p_n$表示，构造$A=p_1p_2p_3…p_n+1$,$A$比这些$p$中的任何一个数都大，因而，必须是合数。同时用$p_1,p_2,…,p_n$去除A所得的余数都是$1$，因此，这些$p$都不是$A$的因子，这与$A$是合数这个结论矛盾，因此，假设不成立，命题得证。
  
  
    Eratosthems筛法求自然数$N$之前的素数表
 &amp;gt; 按大小顺序列出从2到$N$的自然数，然后从2开始，删除2的倍数，然后再删除剩下的第一个数的倍数…一直进行到$\sqrt{N...</content>
  </entry>
  
  <entry>
    <title>零星的面试记忆</title>
    <link href="/2014-05/interview_record.html"/>
    <updated>2014-05-02T00:00:00+08:00</updated>
    <id>/2014-05/interview_record</id>
    <content type="html">记录一下最近碰到的一些面试题目


  
    如果有一个很大的文件(比如10G)存放在1台电脑上，现要将其拷贝至10台不同的电脑，应该怎么做？

    
      最简单的当然是每台电脑依次拷贝，但这肯定不算是一个好方法，然后问了下面试官这些机器之间是否存在网络连接，得到肯定回答，并且每台电脑都相互连接，然后我的回答是将大文件切成很多小块数据，并将这些数据包向与其相连的机器发送，这样，每台机器都能从不同的邻居处获得不同的数据包。然后被追问这样做的时间复杂度是多少，对于这个问题，虽然被提示了很多很多，但我还是没有分析出来，完全不知道如何入手。。。
    
  
  
    一个...</content>
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="/2014-05/hello.html"/>
    <updated>2014-05-01T00:00:00+08:00</updated>
    <id>/2014-05/hello</id>
    <content type="html">作为一个从小就不会写作文的人，第一篇博客实在是太难写了，不过既然折腾了这么久，就不能放弃最初那个写博客冲动，以后尽量多写博客，记录学习经历。

感谢Havee的jekyll-bootstrap模板


作为一个码农

#include &amp;lt;stdio.h&amp;gt;
int main(int argc,char** argv){
  printf(&quot;Hello world!\n&quot;);
}


</content>
  </entry>
  

</feed>
